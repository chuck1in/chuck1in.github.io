<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>java | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:chuck1inzl@gmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><link rel=stylesheet href=https://www.chucklin.net/css/custom.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav><div id=site-header><h1>ChuckLin's Blog</h1><p>Love and Peace 🐷</p></div></header><h2><span class=list-heading-type>tags:</span>
<span class=list-heading-tag>java</span></h2><div id=content><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/spring-security-authority/>Spring Security 如何进行权限验证</a></h2><p class=list-post-date><time datetime=2021-04-05T10:52:00+08:00>5 April, 2021 at 10:52 +0800</time></p></header><div>FilterSecurityInterceptor.doFilter FilterSecurityIntercptor 是负责权限验证的过滤器。一般来说，权限验证是一系列业务逻辑处理完成以后，最后需要解决的问题。所以默认情况下 security 会把和权限有关的过</div><p><a class=read-more href=https://www.chucklin.net/post/spring-security-authority/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/spring-security-custom-auth/>Spring security 自定义 token 身份验证</a></h2><p class=list-post-date><time datetime=2021-04-03T10:52:00+08:00>3 April, 2021 at 10:52 +0800</time></p></header><div>前言 既然 Spring securtiy 的核心是 Filter chains，那我们只需要定义一个符合 security 标准的 filter ，再把自己的 chain 加入到 VirtualFilterChain 里面，就可以自定义身份验证的认证逻辑了。</div><p><a class=read-more href=https://www.chucklin.net/post/spring-security-custom-auth/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/spring-security-auth/>Spring security 如何进行身份认证</a></h2><p class=list-post-date><time datetime=2021-04-02T10:52:00+08:00>2 April, 2021 at 10:52 +0800</time></p></header><div>Filter Spring security 的运行依赖于一系列 filter chains ，其中每一组 filter chain 对应了一种类型的 request type。 当引入 spring security 框架时，会将 security filter chains 注册到 servlet filter chain 上，维护这些 security filter chains 的类就是 FilterChainProxy。</div><p><a class=read-more href=https://www.chucklin.net/post/spring-security-auth/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/goodtest/>什么是优秀的测试？</a></h2><p class=list-post-date><time datetime=2020-01-29T09:51:00+08:00>29 January, 2020 at 09:51 +0800</time></p></header><div>单元测试的质量意义 合理编写单元测试，可使团队工程师告别牛仔式编程，产出易维护的高质量代码。随着单元测试覆盖率的上升，项目会更加的健壮，团队的信心满满，充满斗志。无论是瀑布团队还是敏捷团队，单元测试及自动化单元测试作为重要的质量保证手段的价值已经被大家接纳与认可。
但是，对于大多数团队来讲当测试覆盖率提升一定阶段后，收益会迎来瓶颈。</div><p><a class=read-more href=https://www.chucklin.net/post/goodtest/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/testphilosophy/>单元测试的哲学</a></h2><p class=list-post-date><time datetime=2020-01-27T09:51:00+08:00>27 January, 2020 at 09:51 +0800</time></p></header><div>审美之前先审丑 单元测试的设计不是主观臆断凭直觉的产物。好的设计和工业设计一样，存在着公认的行为准则。 在学习优秀的单元测试设计之前，</div><p><a class=read-more href=https://www.chucklin.net/post/testphilosophy/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/http2/>简述 Http/2</a></h2><p class=list-post-date><time datetime=2020-01-25T09:23:00+08:00>25 January, 2020 at 09:23 +0800</time></p></header><div>先谈谈 Http/0.9 Http/1.0 Http 最初来源于一个构想，即设计一个用于记录、查找和阅读 「由于大量的书面材料或图像材料以复杂的方式相互联系，因此不便在纸介质上呈现或展示」的信息的通用系统。 这个通用系统，由服务器和众多浏览器所组成。
最初的 Http/0.9 基本上只有 Get 方法，没有首部，它只是被用来获取 HTML。经过几年的发展，Http/1.0 在 0.9 的基础上增加了首部、响应码、重定向等功能。</div><p><a class=read-more href=https://www.chucklin.net/post/http2/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/spring_data_hadoop/>为什么选择 Spring data hadoop</a></h2><p class=list-post-date><time datetime=2020-01-20T09:23:00+08:00>20 January, 2020 at 09:23 +0800</time></p></header><div>hbase 常见的操作方式有以下三种：
Native Api 原生 api 操作繁琐，就像用 JDBC 操作关系型数据库一样，类似 flush、submit、close 的使用让人眼花缭乱。如果碰巧你的应用程序使用 java 开发，那就又多了一条不使用 Native Api 的理由 —— 在问题周围兜一个圈子再解决才是真正的 java 式设计。</div><p><a class=read-more href=https://www.chucklin.net/post/spring_data_hadoop/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/webapi2/>web api 的请求与响应</a></h2><p class=list-post-date><time datetime=2020-01-18T09:23:00+08:00>18 January, 2020 at 09:23 +0800</time></p></header><div>恭喜。阅读到本章节的内容代表你领会并且理解了第一章的内容。现在你设计的 Web Api 已经超过了 50%的程序员了。从本章节开始我们来完善 api 设计的各方面细节，向 api 设计专家靠拢。</div><p><a class=read-more href=https://www.chucklin.net/post/webapi2/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/webapi/>什么是好的 Web Api 的设计</a></h2><p class=list-post-date><time datetime=2020-01-17T09:23:00+08:00>17 January, 2020 at 09:23 +0800</time></p></header><div>Web Api 的重要性 web api 就像一张名片一样，专业的名片可以迅速帮助你与客户之间建立信任感，也可能让你的产品在被使用前，就给客户留下业余，糟糕的负面印象。而一旦客户对你的产品产生负面情绪，这种情绪就会蔓延到产品生态圈甚至于相关公司上。</div><p><a class=read-more href=https://www.chucklin.net/post/webapi/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/coroutine/>协程实战</a></h2><p class=list-post-date><time datetime=2020-01-16T09:23:00+08:00>16 January, 2020 at 09:23 +0800</time></p></header><div>并发与并行 计算机自诞生以来，有两方面的性能在持续改进。一是尝试让计算机运行的更快，我们设计了并发使系统具备处理多个任务的能力。二是人类在尝试让计算机做的更多，我们设计了并行使系统可以同时运行多个任务。</div><p><a class=read-more href=https://www.chucklin.net/post/coroutine/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/genericity/>泛型实战</a></h2><p class=list-post-date><time datetime=2020-01-15T09:23:00+08:00>15 January, 2020 at 09:23 +0800</time></p></header><div>泛型是一种将运行时异常转化为编译时异常的一种技术，在与集合有关的应用中，我们经常使用泛型来对集合元素的类型做出约束以让代码更加健壮。</div><p><a class=read-more href=https://www.chucklin.net/post/genericity/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/innerclass/>正确使用内部类</a></h2><p class=list-post-date><time datetime=2020-01-13T09:23:00+08:00>13 January, 2020 at 09:23 +0800</time></p></header><div>Java 的内部类种类较多，语法比较复杂，用法也不尽相同。 由于篇幅所限，本篇文章只对实际项目开发中用的较多的普通内部类与匿名内部类做一定介绍。</div><p><a class=read-more href=https://www.chucklin.net/post/innerclass/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/softskill/>软技能</a></h2><p class=list-post-date><time datetime=2020-01-01T09:23:00+08:00>1 January, 2020 at 09:23 +0800</time></p></header><div>软技能读书笔记 前言 近日读完了约翰森梅兹的著作《软技能-代码之外的生存指南》后受益匪浅。为便于今后对书中重要章节的内容进行反复阅读加深理解，我归纳总结了这篇读书笔记。</div><p><a class=read-more href=https://www.chucklin.net/post/softskill/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/sign_designmode/>单例设计模式</a></h2><p class=list-post-date><time datetime=2018-10-01T18:23:00+08:00>1 October, 2018 at 18:23 +0800</time></p></header><div>单例设计模式是应用最广泛的设计模式，没有之一。当我们需要控制一个类只能被创建出单个对象时，就可以采用单例设计模式。 使用 java 来实现单例设计模式，普遍有四种实现方式。</div><p><a class=read-more href=https://www.chucklin.net/post/sign_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/command_designmode/>命令设计模式</a></h2><p class=list-post-date><time datetime=2018-01-19T09:23:00+08:00>19 January, 2018 at 09:23 +0800</time></p></header><div>什么是命令设计模式 通过将“请求”封装成命令对象，来将操作的请求者与操作的执行者解耦，以便使用不同的请求队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。</div><p><a class=read-more href=https://www.chucklin.net/post/command_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/builder_designmode/>建造者设计模式</a></h2><p class=list-post-date><time datetime=2018-01-12T09:23:00+08:00>12 January, 2018 at 09:23 +0800</time></p></header><div>什么是建造者设计模式 建造者设计模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的一种手段。 建造者设计模式是创建者模式之一。建造者模式往往用来和工厂设计模式做类比，因为这两种设计模式在设计思路上有很相似的地方。 不过需要注意的是，搞清楚这两者的区别非常重要。当理解了两种设计模式对应的问题场景，以及分别用来解决什么样的问题以后，才算真正掌握了建造者设计模式。</div><p><a class=read-more href=https://www.chucklin.net/post/builder_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/decorater_designmode/>装饰器设计模式</a></h2><p class=list-post-date><time datetime=2018-01-05T14:01:23+08:00>5 January, 2018 at 14:01 +0800</time></p></header><div>什么是装饰器设计模式 动态的将责任附加到对象身上。若要扩展功能，装饰着提供了比继承更有弹性的替代方案。</div><p><a class=read-more href=https://www.chucklin.net/post/decorater_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/adpater_designmode/>适配器设计模式</a></h2><p class=list-post-date><time datetime=2018-01-04T11:23:00+08:00>4 January, 2018 at 11:23 +0800</time></p></header><div>什么是适配器设计模式 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</div><p><a class=read-more href=https://www.chucklin.net/post/adpater_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/prototype_designmode/>原型设计模式</a></h2><p class=list-post-date><time datetime=2018-01-03T14:01:23+08:00>3 January, 2018 at 14:01 +0800</time></p></header><div>什么是原型设计模式 用原型实例指定创建对象的种类，并通过拷贝这些原型创建包含了原对象中所有信息的新的对象。 原型设计模式在某种条件下，是一种非常危险的，难以驾驭的设计模式。使用应该慎之又慎。</div><p><a class=read-more href=https://www.chucklin.net/post/prototype_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/strategy_designmode/>策略设计模式</a></h2><p class=list-post-date><time datetime=2018-01-02T14:01:23+08:00>2 January, 2018 at 14:01 +0800</time></p></header><div>策略设计模式定义了算法族（行为族）分别封装起来让他们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。</div><p><a class=read-more href=https://www.chucklin.net/post/strategy_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/status_designmode/>状态设计模式</a></h2><p class=list-post-date><time datetime=2018-01-02T09:48:23+08:00>2 January, 2018 at 09:48 +0800</time></p></header><div>什么是状态设计模式？ 状态设计模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</div><p><a class=read-more href=https://www.chucklin.net/post/status_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/factory_designmode/>工厂设计模式</a></h2><p class=list-post-date><time datetime=2018-01-01T16:43:09+08:00>1 January, 2018 at 16:43 +0800</time></p></header><div>什么是工厂设计模式？ 工厂设计模式是将拥有共性的产品抽象封装到工厂类中统一进行管理和创建，以达到降低使用者与产品之间的耦合度的目的一种手段。 工厂设计模式是创建者模式之一，且从结构上被划分为三大类。三种不同的结构类型，分别对应处理不同的问题。</div><p><a class=read-more href=https://www.chucklin.net/post/factory_designmode/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/deadlock/>什么是死锁</a></h2><p class=list-post-date><time datetime=2017-12-08T15:07:43+08:00>8 December, 2017 at 15:07 +0800</time></p></header><div>什么是死锁 当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b ，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</div><p><a class=read-more href=https://www.chucklin.net/post/deadlock/>Read more &rarr;</a></p></article><article><header><h2 class=list-title><a href=https://www.chucklin.net/post/template_designmode/>模板方法设计模式</a></h2><p class=list-post-date><time datetime=2017-01-07T10:56:57+08:00>7 January, 2017 at 10:56 +0800</time></p></header><div>定义一个操作的主要逻辑方法，而将其他其他逻辑延迟到子类中实现，使子类可以在不改变主要逻辑结构的基础上，即可对某些特定逻辑进行重新实现的做法，叫做模板方法设计模式。</div><p><a class=read-more href=https://www.chucklin.net/post/template_designmode/>Read more &rarr;</a></p></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/avator.jpg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:chuck1inzl@gmail.com>Email me</a></p></div><p class=p-note>从事开发工作10年，持续写作4年，现在的身份是一名 freelancer。项目外包、雇佣洽谈等事项请通过邮箱和我联系。</p></div><div id=footer><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>