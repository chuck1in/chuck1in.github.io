<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>索引的优化技巧 | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:mikumiku.lch@hotmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav></header><div id=content><article class=h-entry><header><h1 class="post-title p-name">索引的优化技巧</h1><p class=post-date>Posted on
<time class=dt-published datetime=2020-02-23T09:52:00+08:00>23 February, 2020 at 09:52 +0800</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a></p></header><section class="content e-content"><h2 id=优化-order-by-语句>优化 Order by 语句</h2><p>众所周知，针对大量数据进行排序费时费力。了解 Mysql 的排序方式是优化数据库排序性能的充分条件。</p><h3 id=索引顺序扫描>索引顺序扫描</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>show</span> <span style=color:#66d9ef>index</span> <span style=color:#66d9ef>from</span> test_index_table
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/bf4ifvp3ybv0zx3w6wn6wdt3/image_1bhd1bbnb91v1hn1fsq1e2e589.png alt=image_1bhd1bbnb91v1hn1fsq1e2e589.png-63.9kB></p><p>在 test_index_table 上我们创建了 3 个索引。Btree 索引的实现原理决定了索引的数据一定是顺序排列的。如果查询语句能够遵循索引数据本身的排列数据进行检索的话，则 mysql 不需要额外的排序工作，操作效率极高。查询类型显示为 Using index。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> age  <span style=color:#66d9ef>FROM</span> test.test_index_table <span style=color:#66d9ef>where</span> age <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;26&#39;</span> <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> age
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/lu0dbk9im9j3dzwcybrtveos/image_1bhd1paf01a7ed63slho0qcem.png alt=image_1bhd1paf01a7ed63slho0qcem.png-50.2kB></p><h3 id=filesort-排序>filesort 排序</h3><p>若碰巧你无法使用索引覆盖扫描，mysql 会将取得的数据在内存中，或者硬盘上对数据进行分块后排序。由于多了一次排序工作，处理效率相比索引覆盖扫描自然就大打折扣了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> age  <span style=color:#66d9ef>FROM</span> test.test_index_table <span style=color:#66d9ef>where</span> age <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;26&#39;</span> <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> id

</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/93spq2fq4dvpjrwi562vhal7/image_1bhd2pcv7qpi1qa72jd12831ukl13.png alt=image_1bhd2pcv7qpi1qa72jd12831ukl13.png-53.4kB>
上面的查询虽然使用了索引作为查询条件，但是却选择了采用 id 作为排序规则进行排序。
根据 age 与根据 id 对应的索引进行排序的结果显然不同，所以 mysql 选择了 Using index 后再进行 Using where 回表扫描后对取出的数据进行排序，增加了数据库负担。</p><h3 id=复合索引的顺序扫描>复合索引的顺序扫描</h3><p>如果你的索引为复合索引，这个问题将变的较为复杂一些。如下表中有 NAME_ADDESS 复合索引。
<img src=http://static.zybuluo.com/mikumikulch/x3k5lm48scquuuarg622i7y9/image_1bhd338e6djrvd01idsvu51v151g.png alt=image_1bhd338e6djrvd01idsvu51v151g.png-45.7kB> 数据按照 name、address 的顺序进行排序。</p><h4 id=复合索引索引覆盖查询>复合索引索引覆盖查询</h4><p>排序条件为 name 时，成功利用索引优化性能</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> name  <span style=color:#66d9ef>FROM</span> test.test_index_table <span style=color:#66d9ef>where</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; 张三&#39;</span> <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span>  name
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/goe5asm6o973zgs9qivli4pz/image_1bhd3s5nv178rm7i1ld3tk21cl11t.png alt=image_1bhd3s5nv178rm7i1ld3tk21cl11t.png-52.1kB></p><h4 id=复合索引回表扫描查询>复合索引回表扫描查询</h4><p>排序条件与索引不相同时，查询类型变为回表扫描。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> name  <span style=color:#66d9ef>FROM</span> test.test_index_table <span style=color:#66d9ef>where</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; 张三&#39;</span> <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span>  address
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/eb4y309eybycpzqckwzipu2c/image_1bhd3vsu2k261o45ct919j317lv2a.png alt=image_1bhd3vsu2k261o45ct919j317lv2a.png-54.8kB>
可见，尽量减少额外的排序，通过索引直接返回有序的数据，是优化 Mysql 排序的关键所在。</p><h2 id=优化-group-by-语句>优化 Group By 语句</h2><p>即使你没有显示的指定 order by 语句，mysql 在默认情况下会多所有 Group By col1，col2 的字段进行排序。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>  <span style=color:#66d9ef>FROM</span> test_index_table <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> age
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/llkjyfplzuxj74divd2ejs52/image_1bhfmijtb10ak1bepsq0dakedm.png alt=image_1bhfmijtb10ak1bepsq0dakedm.png-50.3kB></p><p>如果想要避免排序结果产生的消耗，则可以指定 order by null 禁止排序</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>  <span style=color:#66d9ef>FROM</span> test_index_table <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> age <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>null</span>
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/lj8ue1r5q3nfmvcca8fvu8z8/image_1bhfmk2jl18ubrpohovrip1kuf13.png alt=image_1bhfmk2jl18ubrpohovrip1kuf13.png-49kB></p><h2 id=优化-or-条件>优化 OR 条件</h2><p>含有 or 条件的查询语句，如果想要利用索引，则 or 之前的每个条件列都必须要用到对应的索引。mysql 在处理含有 or 语句的查询时，会对 or 的各个字段分别查询后的结果进行 UNION。</p><h2 id=优化分页查询>优化分页查询</h2><p>类似"limit 1000,20"是相当常见的分页请求。mysql 在处理此类排序时会查询出 1020 条记录，然后舍弃掉前 1000 条数据，代价较高。所以在进行一般分页查询时候，在索引上完成排序分页的操作。尽量减少 mysql 排序时操作的数据量，是一种较为通用的优化思路。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> test.test_index_table <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> age <span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>10000</span>,<span style=color:#ae81ff>20</span>
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/76xzm5psgz9f31ygbjpfsv56/image_1bhkmer3lr4q1ila1tapg3d1g2l9.png alt=image_1bhkmer3lr4q1ila1tapg3d1g2l9.png-51kB></p><p>在数据量巨大的表中使用 limit 分页是相当可怕的一件事情。针对这样的处理，我们就可以按照覆盖索引的方式尽量减少排序时 mysql 操作的数据量。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> test_index_table a <span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> (<span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> test.test_index_table <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> id <span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>10000</span>,<span style=color:#ae81ff>20</span>) b
<span style=color:#66d9ef>on</span> a.id <span style=color:#f92672>=</span> b.id
</code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/pkoun1q19wbxccetkfwhk8lb/image_1bhknak3k1ion1uas1iuk610lej13.png alt=image_1bhknak3k1ion1uas1iuk610lej13.png-69.2kB></p><h2 id=总结>总结</h2><p>本问提及的优化手段虽然十分浅显，但是却至关重要。一个 web 工程大部分的性能问题都是由 database IO 引起的。对 SQL 语句进行适当的合理优化能够解决一个 web 工程 80%的性能问题。</p></section><footer><a class="permalink u-url" href=https://www.chucklin.net/post/sqlindex_tips/>🔗</a><hr class=post-underline><p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/sql class="post-tag p-category">sql</a></p></footer></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/site-logo.svg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:mikumiku.lch@hotmail.com>Email me</a></p></div><p class=p-note>Love and Peace</p></div><div id=footer><nav id=article-skip><div class=next><a alt="Newer article" href=https://www.chucklin.net/post/lockinmysql/>&larr; Newer</a></div><div class=top><a alt="Top of page" href=#>Top</a></div><div class=prev><a alt="Older article" href=https://www.chucklin.net/post/sqlindex_badusage/>Older &rarr;</a></div></nav><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>