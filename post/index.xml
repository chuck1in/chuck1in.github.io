<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on ChuckLin's Blog</title><link>https://example.com/post/</link><description>Recent content in Posts on ChuckLin's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2021 Chuck Lin. All rights reserved.</copyright><lastBuildDate>Mon, 05 Apr 2021 10:52:00 +0800</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Security 如何进行权限验证</title><link>https://example.com/post/springsecurity_authority/</link><pubDate>Mon, 05 Apr 2021 10:52:00 +0800</pubDate><guid>https://example.com/post/springsecurity_authority/</guid><description>FilterSecurityInterceptor.doFilter FilterSecurityIntercptor 是负责权限验证的过滤器。一般来说，权限验证是一系列业务逻辑处理完成以后，最后需要解决的问题。所以默认情况下 security 会把和权限有关的过</description></item><item><title>Spring security 自定义 token 身份验证</title><link>https://example.com/post/springsecurity_authentication2/</link><pubDate>Sat, 03 Apr 2021 10:52:00 +0800</pubDate><guid>https://example.com/post/springsecurity_authentication2/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>既然 Spring securtiy 的核心是 Filter chains，那我们只需要定义一个符合 security 标准的 filter ，再把自己的 chain 加入到 VirtualFilterChain 里面，就可以自定义身份验证的认证逻辑了。&lt;/p></description></item><item><title>Spring security 如何进行身份认证</title><link>https://example.com/post/springsecurity_authentication/</link><pubDate>Fri, 02 Apr 2021 10:52:00 +0800</pubDate><guid>https://example.com/post/springsecurity_authentication/</guid><description>&lt;h2 id="filter">Filter&lt;/h2>
&lt;p>Spring security 的运行依赖于一系列 filter chains ，其中每一组 filter chain 对应了一种类型的 request type。
当引入 spring security 框架时，会将 security filter chains 注册到 servlet filter chain 上，维护这些 security filter chains 的类就是 FilterChainProxy。&lt;/p></description></item><item><title>SSO、OAuth2、与 OpenID connect</title><link>https://example.com/post/oidc/</link><pubDate>Tue, 24 Nov 2020 10:52:00 +0800</pubDate><guid>https://example.com/post/oidc/</guid><description>&lt;h2 id="授权与认证">授权与认证&lt;/h2>
&lt;p>上一章我们一直在反复阐述一个事实： OAuth2 协议是用来解决用户对软件授权的。为何要如此强调这个事实呢？因为授权、认证、单点登录非常容易被混淆。
用户认证是指证明自己的身份。认证有时候会和授权一起使用，就像你去酒店必须首先用身份证证明你的身份，酒店才会授予你使用酒店服务的权利一样。&lt;/p></description></item><item><title>OAuth 2.0 简述</title><link>https://example.com/post/oauth2/</link><pubDate>Tue, 24 Nov 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/oauth2/</guid><description>&lt;h2 id="什么是授权">什么是授权&lt;/h2>
&lt;p>生活中有很多授权的场景，比如：假设你有一辆车，你现在指派一名代驾司机来帮你把车开回家，这就是一种授权。因为你授予了代驾司机使用你的小汽车的权利。在软件领域，授权通常指用户对某软件授予访问受保护资源权限的行为。OAuth2 就是为了将这种行为标准化所设计出来的协议。&lt;/p></description></item><item><title>软件工程师的消失</title><link>https://example.com/post/disappear/</link><pubDate>Sun, 01 Mar 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/disappear/</guid><description>&lt;h2 id="生产力大发展">生产力大发展&lt;/h2>
&lt;p>在现代互联网，完善的基础建设和丰富的自动化工具，极大的缩短和降低了软件开发的周期与成本，现在一个小型的 web 应用的研发计划可能仅需要 5 天。&lt;/p></description></item><item><title>认识数据库锁</title><link>https://example.com/post/lockinmysql/</link><pubDate>Tue, 25 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/lockinmysql/</guid><description>前言 针对不同的存储引擎的数据库锁的实现是不相同的，而现代大型项目基本都选择了 innoDB 作为存储引擎，所以本章节只探讨 innoDB 数据库锁的内容。 innoDB 的</description></item><item><title>索引的优化技巧</title><link>https://example.com/post/sqlindex_tips/</link><pubDate>Sun, 23 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/sqlindex_tips/</guid><description>&lt;h2 id="优化-order-by-语句">优化 Order by 语句&lt;/h2>
&lt;p>众所周知，针对大量数据进行排序费时费力。了解 Mysql 的排序方式是优化数据库排序性能的充分条件。&lt;/p></description></item><item><title>索引的使用误区</title><link>https://example.com/post/sqlindex_badusage/</link><pubDate>Sun, 23 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/sqlindex_badusage/</guid><description>回顾上一章的内容，除了介绍了基本的使用索引优化 sql 语句的基本手法以外，还提到了滥用索引会引起性能恶化的问题。本章节的内容将会举例说明</description></item><item><title>索引的应用</title><link>https://example.com/post/sqlindex/</link><pubDate>Sat, 22 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/sqlindex/</guid><description>&lt;p>经过上一章艰苦卓绝的训练与尝试，我们成功分析出了有问题的 sql 语句。接下来该针对问题语句进行更进一步的优化了。索引往往在这个时候被引入来解决 sql 的运行效率的问题。&lt;/p></description></item><item><title>分析 SQL 语句的一般步骤</title><link>https://example.com/post/analysesql/</link><pubDate>Thu, 20 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/analysesql/</guid><description>&lt;p>数据库的性能调优是一个很大的话题。但是对于开发人员来讲，掌握一些常用的 SQL 优化手段却不是什么难事。
从本章节开始，将连载总结常用的适合于开发人员的 SQL 优化手段与大家分享。&lt;/p></description></item><item><title>跨域资源访问</title><link>https://example.com/post/cors/</link><pubDate>Wed, 19 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/cors/</guid><description>&lt;h2 id="跨域">跨域&lt;/h2>
&lt;p>当一个资源请求一个其它域名或者另外一个端口的资源时会产生一个跨域 HTTP 请求(cross-origin HTTP request)。比如说，http://domaina.example 的某 HTML 页面通过 img 的 src 请求 &lt;a href="http://domainb.foo/image.jpg">http://domainb.foo/image.jpg&lt;/a>。在当今的 Web 开发中，许多页面都会从另外一个站点加载各类资源（包括 CSS、图片、JavaScript 脚本以及其它类资源）。&lt;/p></description></item><item><title>CSRF/XSRF 跨站请求伪造</title><link>https://example.com/post/csrf/</link><pubDate>Tue, 18 Feb 2020 09:52:00 +0800</pubDate><guid>https://example.com/post/csrf/</guid><description>CSRF（Cross Site Request Forgery, 跨站域请求伪造）也称 XSRF， 是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患</description></item><item><title>XSS 跨站脚本攻击</title><link>https://example.com/post/xss/</link><pubDate>Mon, 17 Feb 2020 09:51:00 +0800</pubDate><guid>https://example.com/post/xss/</guid><description>&lt;p>随着互联网技术的发展，现在的 Web 应用都含有大量的动态内容以提高用户体验。所谓动态内容，就是应用程序能够根据用户环境和用户请求，输出相应的内容。动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting, 安全专家们通常将其缩写成 XSS）的威胁，而静态站点则完全不受其影响。&lt;/p></description></item><item><title>SQL 注入</title><link>https://example.com/post/sql_inject/</link><pubDate>Wed, 29 Jan 2020 09:51:00 +0800</pubDate><guid>https://example.com/post/sql_inject/</guid><description>什么是 SQL 注入 SQL 注入攻击（SQL Injection），简称注入攻击，是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，</description></item><item><title>什么是优秀的测试？</title><link>https://example.com/post/goodtest/</link><pubDate>Wed, 29 Jan 2020 09:51:00 +0800</pubDate><guid>https://example.com/post/goodtest/</guid><description>&lt;h2 id="单元测试的意义">单元测试的意义&lt;/h2>
&lt;p>合理编写单元测试，可使团队工程师告别牛仔式编程，产出易维护的高质量代码。随着单元测试覆盖率的上升，项目会更加的健壮，团队的信心满满，充满斗志。无论是瀑布团队还是敏捷团队，单元测试及自动化单元测试作为重要的质量保证手段的价值已经被大家接纳与认可。&lt;/p>
&lt;p>对于大多数团队来讲，当测试覆盖率提升一定阶段后，收益会迎来瓶颈。&lt;/p></description></item><item><title>单元测试的哲学</title><link>https://example.com/post/testphilosophy/</link><pubDate>Mon, 27 Jan 2020 09:51:00 +0800</pubDate><guid>https://example.com/post/testphilosophy/</guid><description>审美之前先审丑 单元测试的设计不是主观臆断凭直觉的产物。好的设计和工业设计一样，存在着公认的行为准则。 在学习优秀的单元测试设计之前，</description></item><item><title>简述 Http/2</title><link>https://example.com/post/http2/</link><pubDate>Sat, 25 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/http2/</guid><description>&lt;h2 id="先谈谈-http09-http10">先谈谈 Http/0.9 Http/1.0&lt;/h2>
&lt;p>Http 最初来源于一个构想，即设计一个用于记录、查找和阅读 「由于大量的书面材料或图像材料以复杂的方式相互联系，因此不便在纸介质上呈现或展示」的信息的通用系统。 这个通用系统，由服务器和众多浏览器所组成。&lt;/p>
&lt;p>最初的 Http/0.9 基本上只有 Get 方法，没有首部，它只是被用来获取 HTML。经过几年的发展，Http/1.0 在 0.9 的基础上增加了首部、响应码、重定向等功能。&lt;/p></description></item><item><title>为什么选择 Spring data hadoop</title><link>https://example.com/post/spring_data_hadoop/</link><pubDate>Mon, 20 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/spring_data_hadoop/</guid><description>&lt;p>hbase 常见的操作方式有以下三种：&lt;/p>
&lt;h3 id="native-api">Native Api&lt;/h3>
&lt;p>原生 api 操作繁琐，就像用 JDBC 操作关系型数据库一样，类似 flush、submit、close 的使用让人眼花缭乱。如果碰巧你的应用程序使用 java 开发，那就又多了一条不使用 Native Api 的理由 —— 在问题周围兜一个圈子再解决才是真正的 java 式设计。&lt;/p></description></item><item><title>web api 的请求与响应</title><link>https://example.com/post/webapi2/</link><pubDate>Sat, 18 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/webapi2/</guid><description>&lt;p>恭喜。阅读到本章节的内容代表你领会并且理解了第一章的内容。现在你设计的 Web Api 已经超过了 50%的程序员了。从本章节开始我们来完善 api 设计的各方面细节，向 api 设计专家靠拢。&lt;/p></description></item><item><title>什么是好的 Web Api 的设计</title><link>https://example.com/post/webapi/</link><pubDate>Fri, 17 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/webapi/</guid><description>&lt;h2 id="web-api-的重要性">Web Api 的重要性&lt;/h2>
&lt;p>web api 就像一张名片一样，专业的名片可以迅速帮助你与客户之间建立信任感，也可能让你的产品在被使用前，就给客户留下业余，糟糕的负面印象。而一旦客户对你的产品产生负面情绪，这种情绪就会蔓延到产品生态圈甚至于相关公司上。&lt;/p></description></item><item><title>协程实战</title><link>https://example.com/post/coroutine/</link><pubDate>Thu, 16 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/coroutine/</guid><description>&lt;h2 id="并发与并行">并发与并行&lt;/h2>
&lt;p>计算机自诞生以来，有两方面的性能在持续改进。一是尝试让计算机运行的更快，我们设计了并发使系统具备处理多个任务的能力。二是人类在尝试让计算机做的更多，我们设计了并行使系统可以同时运行多个任务。&lt;/p></description></item><item><title>泛型实战</title><link>https://example.com/post/genericity/</link><pubDate>Wed, 15 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/genericity/</guid><description>&lt;p>泛型是一种将运行时异常转化为编译时异常的一种技术，在与集合有关的应用中，我们经常使用泛型来对集合元素的类型做出约束以让代码更加健壮。&lt;/p></description></item><item><title>正确使用内部类</title><link>https://example.com/post/innerclass/</link><pubDate>Mon, 13 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/innerclass/</guid><description>&lt;p>Java 的内部类种类较多，语法比较复杂，用法也不尽相同。
由于篇幅所限，本篇文章只对实际项目开发中用的较多的普通内部类与匿名内部类做一定介绍。&lt;/p></description></item><item><title>软技能</title><link>https://example.com/post/softskill/</link><pubDate>Wed, 01 Jan 2020 09:23:00 +0800</pubDate><guid>https://example.com/post/softskill/</guid><description>&lt;h1 id="软技能读书笔记">软技能读书笔记&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>近日读完了约翰森梅兹的著作《软技能-代码之外的生存指南》后受益匪浅。为便于今后对书中重要章节的内容进行反复阅读加深理解，我归纳总结了这篇读书笔记。&lt;/p></description></item><item><title>为什么 Git 与众不同</title><link>https://example.com/post/git/</link><pubDate>Sat, 01 Jun 2019 09:23:00 +0800</pubDate><guid>https://example.com/post/git/</guid><description>&lt;h2 id="关于版本控制系统">关于版本控制系统&lt;/h2>
&lt;blockquote>
&lt;p>按照时间顺序记录某一系列的文件的变更，使其可以查看以前的特定版本的软件，我们称之为版本控制系统。&lt;/p>
&lt;/blockquote>
&lt;p>简单来讲：创建两个文件夹，在两个文件夹中分别保存一月份与二月份的销售数据，这样就创建了一个简单且稳定的版本控制系统。&lt;/p></description></item><item><title>单例设计模式</title><link>https://example.com/post/sign_designmode/</link><pubDate>Mon, 01 Oct 2018 18:23:00 +0800</pubDate><guid>https://example.com/post/sign_designmode/</guid><description>&lt;p>单例设计模式是应用最广泛的设计模式，没有之一。当我们需要控制一个类只能被创建出单个对象时，就可以采用单例设计模式。
使用 java 来实现单例设计模式，普遍有四种实现方式。&lt;/p></description></item><item><title>命令设计模式</title><link>https://example.com/post/command_designmode/</link><pubDate>Fri, 19 Jan 2018 09:23:00 +0800</pubDate><guid>https://example.com/post/command_designmode/</guid><description>&lt;h2 id="什么是命令设计模式">什么是命令设计模式&lt;/h2>
&lt;p>通过将“请求”封装成命令对象，来将操作的请求者与操作的执行者解耦，以便使用不同的请求队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。&lt;/p></description></item><item><title>建造者设计模式</title><link>https://example.com/post/builder_designmode/</link><pubDate>Fri, 12 Jan 2018 09:23:00 +0800</pubDate><guid>https://example.com/post/builder_designmode/</guid><description>&lt;h2 id="什么是建造者设计模式">什么是建造者设计模式&lt;/h2>
&lt;p>建造者设计模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的一种手段。
建造者设计模式是创建者模式之一。建造者模式往往用来和工厂设计模式做类比，因为这两种设计模式在设计思路上有很相似的地方。
不过需要注意的是，搞清楚这两者的区别非常重要。当理解了两种设计模式对应的问题场景，以及分别用来解决什么样的问题以后，才算真正掌握了建造者设计模式。&lt;/p></description></item><item><title>装饰器设计模式</title><link>https://example.com/post/decorater_designmode/</link><pubDate>Fri, 05 Jan 2018 14:01:23 +0800</pubDate><guid>https://example.com/post/decorater_designmode/</guid><description>&lt;h2 id="什么是装饰器设计模式">什么是装饰器设计模式&lt;/h2>
&lt;p>动态的将责任附加到对象身上。若要扩展功能，装饰着提供了比继承更有弹性的替代方案。&lt;/p></description></item><item><title>适配器设计模式</title><link>https://example.com/post/adpater_designmode/</link><pubDate>Thu, 04 Jan 2018 11:23:00 +0800</pubDate><guid>https://example.com/post/adpater_designmode/</guid><description>&lt;h2 id="什么是适配器设计模式">什么是适配器设计模式&lt;/h2>
&lt;p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。&lt;/p></description></item><item><title>原型设计模式</title><link>https://example.com/post/prototype_designmode/</link><pubDate>Wed, 03 Jan 2018 14:01:23 +0800</pubDate><guid>https://example.com/post/prototype_designmode/</guid><description>&lt;h2 id="什么是原型设计模式">什么是原型设计模式&lt;/h2>
&lt;p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建包含了原对象中所有信息的新的对象。
原型设计模式在某种条件下，是一种非常危险的，难以驾驭的设计模式。使用应该慎之又慎。&lt;/p></description></item><item><title>策略设计模式</title><link>https://example.com/post/strategy_designmode/</link><pubDate>Tue, 02 Jan 2018 14:01:23 +0800</pubDate><guid>https://example.com/post/strategy_designmode/</guid><description>&lt;p>策略设计模式定义了算法族（行为族）分别封装起来让他们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。&lt;/p></description></item><item><title>状态设计模式</title><link>https://example.com/post/status_designmode/</link><pubDate>Tue, 02 Jan 2018 09:48:23 +0800</pubDate><guid>https://example.com/post/status_designmode/</guid><description>&lt;h2 id="什么是状态设计模式">什么是状态设计模式？&lt;/h2>
&lt;p>状态设计模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。&lt;/p></description></item><item><title>工厂设计模式</title><link>https://example.com/post/factory_designmode/</link><pubDate>Mon, 01 Jan 2018 16:43:09 +0800</pubDate><guid>https://example.com/post/factory_designmode/</guid><description>&lt;h2 id="什么是工厂设计模式">什么是工厂设计模式？&lt;/h2>
&lt;p>工厂设计模式是将拥有共性的产品抽象封装到工厂类中统一进行管理和创建，以达到降低使用者与产品之间的耦合度的目的一种手段。
工厂设计模式是创建者模式之一，且从结构上被划分为三大类。三种不同的结构类型，分别对应处理不同的问题。&lt;/p></description></item><item><title>什么是死锁</title><link>https://example.com/post/deadlock/</link><pubDate>Fri, 08 Dec 2017 15:07:43 +0800</pubDate><guid>https://example.com/post/deadlock/</guid><description>&lt;h3 id="什么是死锁">什么是死锁&lt;/h3>
&lt;p>当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b ，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。&lt;/p></description></item><item><title>模板方法设计模式</title><link>https://example.com/post/template_designmode/</link><pubDate>Sat, 07 Jan 2017 10:56:57 +0800</pubDate><guid>https://example.com/post/template_designmode/</guid><description>&lt;p>定义一个操作的主要逻辑方法，而将其他其他逻辑延迟到子类中实现，使子类可以在不改变主要逻辑结构的基础上，即可对某些特定逻辑进行重新实现的做法，叫做模板方法设计模式。&lt;/p></description></item></channel></rss>