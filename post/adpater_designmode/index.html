<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>适配器设计模式 | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:mikumiku.lch@hotmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><link rel=stylesheet href=https://www.chucklin.net/css/custom.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav></header><div id=content><article class=h-entry><header><h1 class="post-title p-name">适配器设计模式</h1><p class=post-date>Posted on
<time class=dt-published datetime=2018-01-04T11:23:00+08:00>4 January, 2018 at 11:23 +0800</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a></p></header><section class="content e-content"><h2 id=什么是适配器设计模式>什么是适配器设计模式</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><h2 id=为什么要使用适配器设计模式>为什么要使用适配器设计模式</h2><p>适配器设计模式能够解决的问题，与现实生活中的适配器的用处基本上是一样的。</p><h2 id=适配器设计模式怎么用>适配器设计模式怎么用</h2><p>试想这样一种业务情况。
2001 年，你现在就职的公司为了负责开发了某著名游戏公司所设计的新游戏中的一个模块，而这个模块系统中有一个 duck 类，这个类与其它各种类被打包成 jar 提供给了游戏厂商的系统所使用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * 适配器设计模式
</span><span style=color:#75715e> * 期望对象接口
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Duck</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>quack</span><span style=color:#f92672>();</span>

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fly</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>/**
</span><span style=color:#75715e> * 适配器设计模式
</span><span style=color:#75715e> * 期望对象
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MallardDuck</span> <span style=color:#66d9ef>implements</span> Duck <span style=color:#f92672>{</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>quack</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;gua gua&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fly</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;let me fly&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>


</code></pre></div><p>时过境迁，公司为了适应市场激烈的变化，推出了大量新产品，并设计了许许多多的其它的类。这些新设计的类，有些继承了 Duck 的结构，有些则是独立的、全新的类。比如下面这个全新的火鸡角色。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * 适配器设计模式
</span><span style=color:#75715e> * 被适配对象
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Turkey</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>gobble</span><span style=color:#f92672>();</span>

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fly</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>


<span style=color:#75715e>/**
</span><span style=color:#75715e> * 适配器设计模式
</span><span style=color:#75715e> * 被适配对象
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WildTurkey</span> <span style=color:#66d9ef>implements</span> Turkey <span style=color:#f92672>{</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>gobble</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;gobble gobble&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fly</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;let me fly&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>为了让这款曾经的老游戏焕发新的活力。曾经的接口必需适应新产品的结构才行。要达到这样的目的，有两个方法</p><ul><li>通知曾经的游戏厂商，为了我司全新的游戏产品重新设计游戏接口。</li><li>想办法让我司的新产品能够适应老旧的游戏厂商接口。</li></ul><p>第一个方法显然是不现实的。所以，我们需要采用适配器设计模式，让它帮助我们使新产品能够运用到旧的接口上去。
适配器类要做的工作非常简单。持有被适配对象的引用，并实现期望对象接口就可以了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * 适配器设计模式
</span><span style=color:#75715e> * 适配器对象
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TurkeyAdapter</span> <span style=color:#66d9ef>implements</span> Duck <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>private</span> Turkey turkey<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>TurkeyAdapter</span><span style=color:#f92672>(</span>Turkey turkey<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>turkey</span> <span style=color:#f92672>=</span> turkey<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>quack</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        turkey<span style=color:#f92672>.</span><span style=color:#a6e22e>gobble</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fly</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        turkey<span style=color:#f92672>.</span><span style=color:#a6e22e>fly</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>通知厂商在新的游戏系统中加上全新的火鸡角色，让这款游戏变得更加丰富多彩。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * 适配器设计模式
</span><span style=color:#75715e> * 客户端
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Client</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Duck duck <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MallardDuck<span style=color:#f92672>();</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        duck<span style=color:#f92672>.</span><span style=color:#a6e22e>fly</span><span style=color:#f92672>();</span>
        duck<span style=color:#f92672>.</span><span style=color:#a6e22e>quack</span><span style=color:#f92672>();</span>

        duck <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TurkeyAdapter<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> WildTurkey<span style=color:#f92672>());</span>
        duck<span style=color:#f92672>.</span><span style=color:#a6e22e>fly</span><span style=color:#f92672>();</span>
        duck<span style=color:#f92672>.</span><span style=color:#a6e22e>quack</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><pre><code>let me fly
gua gua
let me fly
gobble obble
</code></pre><p>将上面的思路与代码做一下归纳与整理，适配器设计模式的类图也就迎刃而出了。最后通过 UML 类图再来加深一下对适配器设计模式的印象。
<img src=http://static.zybuluo.com/mikumikulch/p3u4nb8cck49jkz92go8v62a/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-10%20%E4%B8%8B%E5%8D%886.19.42.png alt="屏幕快照 2017-01-10 下午6.19.42.png-19.7kB"></p><h2 id=总结>总结</h2><p>适配器设计模式理解与运用上都比较简单。值得注意的是：适配器设计模式乍看起来与装饰器设计模式，但是这两个设计模式对应处理的是完全不同的问题。
装饰器设计模式的重点在于动态的为对象添加责任，并且被装饰对象的结构，接口必需与组件相同，并且在装饰过程中，被装饰对象与组建的接口不能发生变化。
而适配器设计模式的重点在于将不匹配的接口通过封装，将被适配对象的接口改变成为所期望的接口。</p></section><footer><a class="permalink u-url" href=https://www.chucklin.net/post/adpater_designmode/>🔗</a><hr class=post-underline><p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/java class="post-tag p-category">java</a></p></footer></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/avator.jpg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:mikumiku.lch@hotmail.com>Email me</a></p></div><p class=p-note>👋很高兴见到你。 我从事一线开发工作10年了，现在的身份的是一名 freelancer。项目外包，雇佣洽谈等事项请通过邮箱和我联系。</p></div><div id=footer><nav id=article-skip><div class=next><a alt="Newer article" href=https://www.chucklin.net/post/decorater_designmode/>&larr; Newer</a></div><div class=top><a alt="Top of page" href=#>Top</a></div><div class=prev><a alt="Older article" href=https://www.chucklin.net/post/prototype_designmode/>Older &rarr;</a></div></nav><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>