<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<title>索引的物理结构 | ChuckLin's Blog</title>
<meta name=description content="Love and Peace">
<meta name=author content>
<link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png>
<link rel=manifest href=https://www.chucklin.net/site.webmanifest>
<link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a>
<meta name=msapplication-TileColor content="#00aba9">
<meta name=theme-color content="#ffffff">
<link rel=me href=mailto:mikumiku.lch@hotmail.com>
<link rel=me href=https://github.com/chuck1in>
<link rel=authorization_endpoint href=https://indieauth.com/auth>
<link rel=token_endpoint href=https://tokens.indieauth.com/token>
<link rel=stylesheet href=https://www.chucklin.net/css/fonts.css>
<link rel=stylesheet href=https://www.chucklin.net/css/style.css>
<link rel=stylesheet href=https://www.chucklin.net/css/custom.css>
<meta name=viewport content="width=device-width,initial-scale=1">
<script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<div id=sitelogo>
<a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a>
</div>
<header>
<nav>
<div id=page-nav>
<div class=page-nav-item>
<a href=https://www.chucklin.net/>Home</a>
</div>
<div class=page-nav-item>
<a href=/about/me>
<span>About</span>
</a>
</div>
<div class=page-nav-item>
<a href=/tags>
<span>Tag</span>
</a>
</div>
</div>
</nav>
</header>
<div id=content>
<article class=h-entry>
<header>
<h1 class="post-title p-name">索引的物理结构</h1>
<p class=post-date>Posted on
<time class=dt-published datetime=2021-09-08T14:28:26+08:00>
8 September, 2021 at 14:28 +0800
</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a>
</p>
</header>
<section class="content e-content">
<h2 id=行的格式>行的格式</h2>
<p>在 innodb 存储引擎中，一个表中的记录（records）会按照固定的行格式根据字符集的比较规则，按照主键顺序存储到硬盘上。</p>
<p><img src=/images/mysql/row.jpg alt=row></p>
<p>上图中的行格式就规定：除了保存记录的列信息以外，还需要在行中保存额外的信息，如：变长字段的占为长度、空值的列、行的头（head）信息等。
行的头信息中有一个名为 next_record 的指向下一条记录在磁盘上的偏移量的指针，使表中的行构成一个链表，链表的各个节点通过指向磁盘偏移量的指针进行连接。</p>
<h2 id=页>页</h2>
<p>innodb 规定，每次从磁盘检索加载数据都以页（16KB/页）为单位。再进一步讲，页就是 innodb 管理存储空间的基本单位。
页有不同的类型，用来保存用户数据的页称为索引页/数据页。一个简化的数据页结构如下所示：</p>
<p><img src=/images/mysql/page.jpg alt=page></p>
<p>可见，一个数据页除了保存 user records 以外，还保存了页的元数据（meta data）。</p>
<h3 id=页目录>页目录</h3>
<p>由于数据表中的 record 使用 next_record 指针构成一个链表，所以下面查找某一行数据的查询语句</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</code></pre></div><p>在物理上就是已知一个链表的地址，查找链表中某节点的问题。而查找链表中的节点通常可以采用线性查找法来实现。但是线性查找法的时间复杂度是$O(n$)，如果数据量较大这个时间复杂度是难以接受的。</p>
<p>为了降低查询的时间复杂度， innodb 采取了类似文件目录的方案。
首先将用户数据进行逻辑分组，再将每组中最大的记录的地址偏移量集中存储到一起的。当查询某条记录时，先查询记录所在的分组（文件目录），再进入组内（目录内）查找，这样就缩小了线性查找的范围。</p>
<p><img src=/images/mysql/page-directory.jpg alt=directory></p>
<p>像这样对数据进行逻辑分组，然后再选取记录分组地址偏移量进行集中存储的空间，我们称为页目录（Page Directory）。</p>
<p>前面提到过 records 是按照主键顺序排列的，所以在页目录中还可以利用二分查找提升页目录的搜索效率，将时间复杂度降低为$O(\log n)$</p>
<h2 id=聚簇索引>聚簇索引</h2>
<p>页的大小是有限的（16KB）。如果表中的记录超出了这个容量，那就得使用多个关联页来存储。这些关联页之间通过指针连接形成一个双向链表。</p>
<p><img src=/images/mysql/page-dirs.jpg alt=dirs></p>
<p>所以当使用多个页存储数据时，查询用户记录的工作就变为了两步：</p>
<ol>
<li>确定记录所在的页的地址。</li>
<li>在页中通过页目录查找记录在页中的偏移量。</li>
</ol>
<p>因为关联的数据页是一个链表结构，所以通过线性查找法肯定可以找到被查找记录所在的页，但是在数据量较大时也存在一样的性能问题。</p>
<p>那么，是否可以参考页目录的设计将页进行分组呢？先按照页号分组，并保证分组按照数据页中的用户记录的主键顺序进行排序，最后再用一个数据页作为分组后的目录，保存各组中数据页内最小的主键值。</p>
<p><img src=/images/mysql/index.jpg alt=index></p>
<p>经过这样的构建，复数个关联页形成了一颗 B 树。树根所在的节点就是根页(root page)；存储页号的数据页被称为目录项页；整棵树就是聚簇索引。</p>
<p>假设我们使用指定值的主键（或者唯一二级索引）为条件，对这个聚簇索引进行查询的话，这个查询的速度会像火箭一样快。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> A
<span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
<span style=color:#f92672>//</span> <span style=color:#66d9ef>output</span>: id:<span style=color:#ae81ff>5</span> code:b
</code></pre></div><p>先通过聚簇索引的目录页利用二分查找定位到 id=5 的记录应该在页号为 2 的页中，然后在页目录（Page directory）中再使用二分查找定位到 id=5 的记录在页中的偏移量就能获取到记录内容。</p>
<p>这种像火箭一样快的查询方法，我们称为常数方法（const）——因为他的效率就和$O(1$)一样好。</p>
<h2 id=二级索引>二级索引</h2>
<p>针对非主键建立的索引就是二级索引。相比聚簇索引，二级索引的叶节点只存储了两类信息：索引项与索引项对应的主键。</p>
<p><img src=/images/mysql/ref.jpg alt=ref></p>
<p>由于二级索引没有存储用户记录的所有列信息，所以针对二级索引的查询工作就变成了三步：</p>
<ol>
<li>确定记录所在的页。</li>
<li>在页中通过页目录查找。</li>
<li>查找到二级索引对应的主键后，回聚簇索引查找完整的内容。</li>
</ol>
<p>这种回聚簇索引查询用户记录的情况，我们称为回表扫描。通过二级索引进行查询的方法称为 ref 查询方法，它的性能相比 const 方法要低一些。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> A
<span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>;
<span style=color:#f92672>//</span> <span style=color:#66d9ef>output</span>: code:a id:<span style=color:#ae81ff>1</span>
</code></pre></div><p>如果我们只需要根据二级索引查询 id（主键）的信息，那么就不需要回表扫描了，通过二级索引就可以直接返回结果。这种查询方法称为索引覆盖（index）查询方法。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> B
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>;
<span style=color:#f92672>//</span> <span style=color:#66d9ef>output</span>: id:<span style=color:#ae81ff>1</span>
</code></pre></div><h2 id=联合索引>联合索引</h2>
<p>联合索引就是由多个字段组合，并按照联合字段的顺序对用户记录进行排序的二级索引。</p>
<p><img src=/images/mysql/union-index.jpg alt=union></p>
<p>针对联合索引进行查询时，要注意查询条件需遵守「左前缀原则」，这是由联合索引的底层构造所决定的。不然就无法利用联合索引进行查询。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> A
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> code2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;b&#39;</span>;
<span style=color:#f92672>//</span> <span style=color:#66d9ef>output</span>: id:<span style=color:#ae81ff>1</span>

<span style=color:#f92672>//</span> B
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>
<span style=color:#f92672>//</span> <span style=color:#66d9ef>output</span>: id:<span style=color:#ae81ff>1</span>

<span style=color:#f92672>//</span> <span style=color:#66d9ef>C</span>
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;b&#39;</span> <span style=color:#66d9ef>and</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>;
<span style=color:#f92672>//</span> <span style=color:#66d9ef>output</span>: id:<span style=color:#ae81ff>1</span>


</code></pre></div><p>上面的语句中，A 语句和 B 语句的查询条件（code && code2）、（code）和联合索引（code,code2）的索引字段顺序一致，所以可以通过索引树提高查找效率。
B 语句的查询条件不符合索引字段的顺序，所以无法利用索引树查询提高效率，存储引擎在执行时会使用全表扫描查询方法（all）。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> D
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> code2 <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#39;g&#39;</span>

<span style=color:#f92672>//</span> E
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> code2 <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#39;g&#39;</span> <span style=color:#66d9ef>and</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</code></pre></div><p>查询语句 D 是一个针对联合索引的范围查询(Range)。因为联合索引按照 (code,code2) 排序，所以 (code,code2) 的范围条件可以形成一个有效的扫描区间$[(a,\forall),(a,g)]$ 。</p>
<p>查询语句 E 中增加了一个 <code>id=6</code> 的条件，这个条件并不是联合索引的排序字段，所以它不能提供有效的扫描区间，可以直接将 <code>id=6</code> 被替换为 TRUE 。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> E
<span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> code2 <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#39;g&#39;</span> <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>TRUE</span>
</code></pre></div><p>TRUE 和前两个条件 (code,code2) 使用 and 进行连接。从扫描区间上来说，就是对 $(-\infty,+\infty)$和$[(a,\forall),(a,g)]$ 取并集。于是整个查询语句的扫描区间就是 $[(a,\forall),(a,g)]$。</p>
<h2 id=使用索引排序和分组>使用索引排序和分组</h2>
<h4 id=排序>排序</h4>
<p>对于大数据量进行排序是比较耗时的。这不仅仅是在内存中运行排序算法的 CPU 成本，还有将排序的中间结果保存到磁盘造成的 IO 成本。
但是若利用索引的物理结构本身有序的这个特性，就可以省去额外的排序工作。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#f92672>//</span> F
<span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>where</span> code <span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> code2 <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#39;g&#39;</span> <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> code;
</code></pre></div><p>上面已经提到过，F 这个查询语句会根据扫描区间扫描二级索引并回表查询记录。当完成扫描区间的二级索引回表查询的工作，并整合结果集后，由于查询语句的排序条件，就是联合索引的排序条件，所以省去了额外的排序的步骤，innodb 可以直接将结果集返回给客户端。</p>
<h4 id=分组>分组</h4>
<p>分组操作如果缺少索引，innodb 会在扫描聚簇索引的记录时，新建一个临时表来存储分组的统计结果。统计完成后，将临时表的内容发送给客户端。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>select</span> <span style=color:#66d9ef>count</span>(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> code, code2
</code></pre></div><p>如果分组的字段有索引，并且顺序和索引顺序相同，那就没有必
要建立中间表进行统计了，直接使用索引项就即可完成分组了。</p>
<h2 id=表连接中的索引>表连接中的索引</h2>
<p>表的连接其实就是索引的连接。 TODO</p>
</section>
<footer>
<a class="permalink u-url" href=https://www.chucklin.net/post/sqlindex_principle/>🔗</a>
<hr class=post-underline>
<p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/sql class="post-tag p-category">sql</a>
</p>
</footer>
</article>
</div>
<div class=h-card>
<img class=u-photo src=https://www.chucklin.net/images/avator.jpg>
<div class=card-content>
<h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2>
<p class=card-subhead>
<span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br>
<a class=u-email href=mailto:mikumiku.lch@hotmail.com>Email me</a>
</p>
</div>
<p class=p-note>从事开发工作10年，持续写作4年，现在的身份是一名 freelancer。项目外包、雇佣洽谈等事项请通过邮箱和我联系。</p>
</div>
<div id=footer>
<nav id=article-skip>
<div class=next>
<p>&nbsp;</p>
</div>
<div class=top>
<a alt="Top of page" href=#>Top</a>
</div>
<div class=prev>
<a alt="Older article" href=https://www.chucklin.net/post/ts_enum/>Older &rarr;</a>
</div>
</nav>
<aside id=social>
<div id=social-icons>
<div class=icon-24x24>
<a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a>
</div>
</div>
</aside>
<p class=copyright>
Copyright © 2021 Chuck Lin. All rights reserved.
</p>
</div>
</body>
</html>