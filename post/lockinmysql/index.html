<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>认识数据库锁 | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:chuck1inzl@gmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><link rel=stylesheet href=https://www.chucklin.net/css/custom.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav></header><div id=content><article class=h-entry><header><h1 class="post-title p-name">认识数据库锁</h1><p class=post-date>Posted on
<time class=dt-published datetime=2020-02-25T09:52:00+08:00>25 February, 2020 at 09:52 +0800</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a></p></header><section class="content e-content"><h2 id=前言>前言</h2><p>针对不同的存储引擎的数据库锁的实现是不相同的，而现代大型项目基本都选择了 innoDB 作为存储引擎，所以本章节只探讨 innoDB 数据库锁的内容。</p><p>innoDB 的数据库锁与事务特性息息相关。所以在探讨开始之前，先来回顾一下 innoDB 的事务特性，会有助于理解后续的内容。</p><h4 id=事务的挑战与-acid-属性>事务的挑战与 ACID 属性</h4><p>事务是  构建健壮系统不可获取的条件之一。构建一个完善的事务至少要面临以下挑战。</p><ul><li>更新丢失：两个并行操作，后进行的操作覆盖掉了先进行操作的操作结果，被称作更新丢失。</li><li>脏读：一个事务在提交之前，在事务过程中修改的数据，被其他事务读取到了。</li><li>不可重复读：一个事务在提交之前，在事务过程中读取以前的数据却发现数据发生了改变。</li><li>幻读：一个事务按照相同的条件重新读取以前检索过的数据时，却发现了其他事务插入的新数据。</li></ul><p>对于上述挑战，除了更新丢失应该通过应用程序完全避免以外，其他都可以通过数据库的隔离等级提供的事务 ACID 特性保证得到解决。</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><p>提供 ACID 特性保证的手段有两种，一种是 MVCC 多版本控制系统，还有一种就是利用锁。</p><h2 id=数据库中的锁>数据库中的锁</h2><p>数据库的锁按照类型可划分为共享锁与排他锁。</p><ul><li>共享锁：允许一个事务读取一行，阻止其他事务获得相同数据集的排他锁。但允许其他事务获取共享锁。</li><li>排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享与排他锁。但是可以对获取了排他锁的数据集进行单纯的查询访问。</li></ul><p>在「可重复读」的隔离等级下，对于普通的 select 语句，InnoDB 默认使用 MVCC 来提供可重复度隔离等级的事务特性保证。
对于非普通的 select 语句，如：Update、Delete、insert、select for update/share 等，，InnoDB 会自动给涉及的数据集加上排他锁或共享锁。</p><h3 id=死锁>死锁</h3><p>假设你足够细心，可能已经察觉到死锁的隐患了。多个线程持有某个数据集的共享锁，再尝试获取排他锁时会发生什么情况？</p><p><strong>session 1 -> 针对 age = 26 的记录加共享锁</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>test_index_table<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>name<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>birthday<span style=color:#f92672>`</span> datetime <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>address<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>phone<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>note<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>age<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>NAME_ADDRESS<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>name<span style=color:#f92672>`</span>,<span style=color:#f92672>`</span>address<span style=color:#f92672>`</span>) <span style=color:#66d9ef>USING</span> BTREE,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>AGE<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>age<span style=color:#f92672>`</span>) <span style=color:#66d9ef>USING</span> BTREE
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB AUTO_INCREMENT<span style=color:#f92672>=</span><span style=color:#ae81ff>283</span> <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> test_index_table <span style=color:#66d9ef>where</span> age <span style=color:#f92672>=</span> <span style=color:#ae81ff>26</span> <span style=color:#66d9ef>lock</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>share</span> <span style=color:#66d9ef>mode</span>;
</span></span></code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/563oeetth50hj2fhbtc60f49/image_1bjc51gaf1douqq81uqgg2h3fi2n.png alt=image_1bjc51gaf1douqq81uqgg2h3fi2n.png-100.6kB></p><p><strong>session 2 -> 针对 age = 26 的记录加共享锁</strong>
<img src=http://static.zybuluo.com/mikumikulch/1afl0b7mgm5fnt2pcdnsybuz/image_1bjc54stv177b1jg41i72171mo7534.png alt=image_1bjc54stv177b1jg41i72171mo7534.png-95.3kB></p><p><strong>session 1 -> 针对 age = 26 的记录获取排他锁</strong></p><p>由于当前数据集已经被 session 2 获取到了共享锁，无法再获取排他锁，操作阻塞。（道理很简单，文件被读取的时候不允许写入）
<img src=http://static.zybuluo.com/mikumikulch/3j7oxesz3e932mvtjt8irav9/image_1bjc56gu81pji1c1a1cuv1elmtgt3h.png alt=image_1bjc56gu81pji1c1a1cuv1elmtgt3h.png-25.9kB></p><p><strong>session 2 -> 针对 age = 26 的记录获取排他锁</strong>
由于当前数据集已经被 session 1 获取了共享锁，无法再获取排他锁，造成循环等待，数据库死锁操作退出。
<img src=http://static.zybuluo.com/mikumikulch/er7heh4d03hqmxac39b3pkk6/image_1bjc575bc1u001u2hormh858c33u.png alt=image_1bjc575bc1u001u2hormh858c33u.png-134.5kB></p><p>可见，两个 session 获得同一个数据集的共享锁，再分别尝试获取排他锁时会造成循环依赖，就会引起数据库死锁报错，操作退出。</p><h2 id=行锁与索引>行锁与索引</h2><p>光理解锁的基本概念是远远不够的。在 InnoDB 中，行锁是通过给索引上的索引项加锁来实现的。如果没有索引，InnoDB 就会对整张表加锁。另外，根据针对 sql 语句检索条件的不同，加锁又有以下三种情形需要我们掌握。</p><ul><li>Record lock：对索引项加锁。</li><li>Gap lock：对索引项之间的间隙加锁。</li><li>Next-key lock：对当前记录和记录前面的间隙加锁。</li></ul><h3 id=record-lock对索引项加锁若没有索引项则使用表锁>Record lock：对索引项加锁。若没有索引项则使用表锁。</h3><p>InnoDB 针对索引进行加锁的实现方式意味着：只有通过索引条件检索或者更新数据，InnoDB 才使用行级锁，否则 InnoDB 将会使用表锁更新数据，极大地降低数据库的并发执行性能。</p><p><strong>session 1 -> 尝试对非索引件进行检索或者 update 获取排他锁。</strong>
现有一张拥有 NAME_ADDRESS 的复合索引与主键索引的数据表。请注意，AGE 索引已经被我删除了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>test_index_table<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>name<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>birthday<span style=color:#f92672>`</span> datetime <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>address<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>phone<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>note<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>age<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>NAME_ADDRESS<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>name<span style=color:#f92672>`</span>,<span style=color:#f92672>`</span>address<span style=color:#f92672>`</span>) <span style=color:#66d9ef>USING</span> BTREE
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB AUTO_INCREMENT<span style=color:#f92672>=</span><span style=color:#ae81ff>283</span> <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8
</span></span></code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/h24ba6g86xl0kfbrzd3sh5xc/image_1bjc6kdko8ab31465117k510fc4b.png alt=image_1bjc6kdko8ab31465117k510fc4b.png-150.2kB></p><p>尝试对这张表进行非索引项的 Modify 语句。回想之前的概念：modify 语句会自动给当前数据集加上排他锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>update</span> test_schema.test_index_table <span style=color:#66d9ef>set</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;王二&#39;</span> <span style=color:#66d9ef>where</span> age <span style=color:#f92672>=</span> <span style=color:#ae81ff>26</span>
</span></span></code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/crz1zsnmn5z4z9o2w5dkj0eo/image_1bjc72brk1q6f8emjg01kts1fla4o.png alt=image_1bjc72brk1q6f8emjg01kts1fla4o.png-55.1kB></p><p><strong>session2 -> 尝试对 age 为 27 的记录进行更新。</strong>
由于 age 字段为非索引字段，所以 session1 使用了表锁而非行锁来确保数据库并发访问的一致性。造成了 session 2 的更新操作阻塞。
<img src=http://static.zybuluo.com/mikumikulch/uiycr0yv0hcmzvyms2qj7xug/image_1bjc8m5pl140tb8tu0rk3g15so55.png alt=image_1bjc8m5pl140tb8tu0rk3g15so55.png-18kB></p><p><strong>session1 -> 释放 session1 的表锁。</strong>
<img src=http://static.zybuluo.com/mikumikulch/ch16dmclf6ebl1di5y6gheup/image_1bjc8p7431rf41ln915fu8i3ujr5i.png alt=image_1bjc8p7431rf41ln915fu8i3ujr5i.png-61.7kB></p><p><strong>session2 -> 更新操作执行成功。</strong>
<img src=http://static.zybuluo.com/mikumikulch/p9d8c0o4sisxfn6qoufjbfou/image_1bjc8pv00vna1ud0r0nhns1j3i5v.png alt=image_1bjc8pv00vna1ud0r0nhns1j3i5v.png-40.6kB></p><h3 id=针对索引加锁而不是针对记录加锁>针对索引加锁，而不是针对记录加锁</h3><p>刚才已经提到 innoDB 的行锁的实现方式是基于索引项的。这意味着即使你尝试获取不同行的排他锁，若使用了相同的索引键，也可能会造成锁冲突。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>test_index_table<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>name<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>birthday<span style=color:#f92672>`</span> datetime <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>address<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>phone<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>note<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>age<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>NAME_ADDRESS<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>name<span style=color:#f92672>`</span>,<span style=color:#f92672>`</span>address<span style=color:#f92672>`</span>) <span style=color:#66d9ef>USING</span> BTREE,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>AGE<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>age<span style=color:#f92672>`</span>) <span style=color:#66d9ef>USING</span> BTREE
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB AUTO_INCREMENT<span style=color:#f92672>=</span><span style=color:#ae81ff>283</span> <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8
</span></span></code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/qigl3diwm8rsq2wjgx4ek31z/image_1bjcac76j1fen1ep2bq46lj1fip7j.png alt=image_1bjcac76j1fen1ep2bq46lj1fip7j.png-146.1kB></p><p><strong>session1 -> 针对 age = 29 and address = 东京 获取排他锁。</strong>
通过观察表很容易得出本次我们期望获取排他锁的数据集应该是 id = 150 的记录。
<img src=http://static.zybuluo.com/mikumikulch/9sfqnnodmv3c46ql56d7773c/image_1bjcakqph1ma917icjmtv42pvr80.png alt=image_1bjcakqph1ma917icjmtv42pvr80.png-51.7kB></p><p><strong>session1 -> 针对 age = 29 and address = 北京 获取排他锁。</strong>
尝试更新 id = 149 记录的操作竟然阻塞了。
<img src=http://static.zybuluo.com/mikumikulch/k3kk1o189szaj65f7jolj6i6/image_1bjcamhi417f8q44b19j2u1lnn8d.png alt=image_1bjcamhi417f8q44b19j2u1lnn8d.png-31.8kB></p><p>更新不同行的数据集，却产生了排他锁阻塞的原因其实很简单。由于 mysql 的行锁的实现方式基于索引，所以 149 与 150 对应到的二级索引项实际是同一个。所以 session2 在尝试获取排他锁时操作被 session1 阻塞。</p><h3 id=next-key-锁>next-key 锁</h3><p>当利用范围条件而不是相等条件获取排他锁时，innoDB 会给符合条件的所有数据加锁。对于在条件范围内但是不存在的记录，叫做间隙。innoDB 也会对这个间隙进行加锁。另外，使用相等的检索条件时，若指定了本身不存在的记录作为检索条件的值的话，则此值对应的索引项也会加锁。</p><p><strong>session 1 -> age >= 25 的索引项获取排他锁</strong>
<img src=http://static.zybuluo.com/mikumikulch/j6525nuyfmjhh446sm6jks9j/image_1bjcbkjc0hvp4j4km5stkj4a8q.png alt=image_1bjcbkjc0hvp4j4km5stkj4a8q.png-44.8kB></p><p><strong>session 2 -> age = 39 的索引项获取排他锁</strong>
由于 session1 的操作产生了 next-key 锁的原因操作被阻塞
<img src=http://static.zybuluo.com/mikumikulch/nbzrw53sehnotmu4jw5pihgs/image_1bjcbqhmr1di61iqk121ts151eee97.png alt=image_1bjcbqhmr1di61iqk121ts151eee97.png-17.3kB></p><p><strong>session 1 -> 释放锁。</strong>
<img src=http://static.zybuluo.com/mikumikulch/2upu8iqks58y7jedth4fu7mp/image_1bjcbtjmh1k7s1kr61sqhcr31bv89k.png alt=image_1bjcbtjmh1k7s1kr61sqhcr31bv89k.png-15.3kB></p><p><strong>session 2 -> 操作执行成功。同时给 age = 39 的索引项增加了 next-key 锁。</strong>
<img src=http://static.zybuluo.com/mikumikulch/161c2ahs6rotd3yagipybyb4/image_1bjcbud3c1ffnnuh11ghmt9vea1.png alt=image_1bjcbud3c1ffnnuh11ghmt9vea1.png-41.7kB></p><p><strong>session 1 -> 尝试更新 age = 39 的索引项对应的记录。</strong>
由于上一步 session 2 的 next-key 锁的原因，本次操作被阻塞。
<img src=http://static.zybuluo.com/mikumikulch/jog28f29lmkp1vo8ax3xubtv/image_1bjcc082u1nh1ur91bkl82mm9ae.png alt=image_1bjcc082u1nh1ur91bkl82mm9ae.png-16.9kB></p><p>可见，凡是会引起 next-key 锁的操作都需要慎重考虑。稍不留意就会大幅度降低数据库的并发操作性能。也许你会觉得 next-key 锁的实现是不是欠妥。但是，mysql innoDB 实现 next-key 锁的一个重要原因就是为了防止事务的幻读。
当存在 next-key 的情况下，执行中的事务无论外部插入多少数据也不会在事务提交之前读到新插入的数据集，从而保证了事务的一致性。</p><h2 id=检查-innodb-行锁争用的情况>检查 InnoDB 行锁争用的情况</h2><h4 id=检查-innodb_row_lock-状态变量分析系统上的行锁竞争情况>检查 InnoDB_row_lock 状态变量分析系统上的行锁竞争情况</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>show</span> status <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#34;innodb_row_lock%&#34;</span>
</span></span></code></pre></div><p>如果锁竞争严重，innoDB_row_lock_waits 和 innoDB_row_lock_time_avg 的值比较高，则通过 information_schema 数据库中的表来查看锁情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> information_schema.innodb_locks
</span></span></code></pre></div><p><img src=http://static.zybuluo.com/mikumikulch/abp1qsmsx3no8ou8i6huk1b5/image_1bjcd4j8t8vm1nh51ohn1g9c13chb8.png alt=image_1bjcd4j8t8vm1nh51ohn1g9c13chb8.png-60kB></p><h2 id=结语>结语</h2><p>大型 web 应用通常都离不开数据库，而现代工程的性能瓶颈往往都在 IO 处理上。若想在面临 IO 处理时作出最佳实践，就应该建立全面的数据库应用知识体系。</p><hr><p><em>参考书籍</em>
<em>《深入浅出 mysql》</em></p></section><footer><a class="permalink u-url" href=https://www.chucklin.net/post/lockinmysql/>🔗</a><hr class=post-underline><p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/sql class="post-tag p-category">sql</a></p></footer></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/avator.jpg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:chuck1inzl@gmail.com>Email me</a></p></div><p class=p-note>从事开发工作10年，持续写作4年，现在的身份是一名 freelancer。项目外包、雇佣洽谈等事项请通过邮箱和我联系。</p></div><div id=footer><nav id=article-skip><div class=next><a alt="Newer article" href=https://www.chucklin.net/post/disappear/>&larr; Newer</a></div><div class=top><a alt="Top of page" href=#>Top</a></div><div class=prev><a alt="Older article" href=https://www.chucklin.net/post/index_tips/>Older &rarr;</a></div></nav><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>