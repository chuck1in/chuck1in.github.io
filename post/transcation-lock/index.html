<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>事务与锁的设计思想 | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:chuck1inzl@gmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><link rel=stylesheet href=https://www.chucklin.net/css/custom.css><meta name=viewport content="width=device-width,initial-scale=1"><script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav></header><div id=content><article class=h-entry><header><h1 class="post-title p-name">事务与锁的设计思想</h1><p class=post-date>Posted on
<time class=dt-published datetime=2021-09-14T16:30:57+08:00>14 September, 2021 at 16:30 +0800</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a></p></header><section class="content e-content"><p>事务是一个抽象的概念，代表一个或多个数据库操作。比如下面这三组查询语句 A、B、C 分别代表三个事务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> autocommit <span style=color:#f92672>=</span> <span style=color:#66d9ef>ON</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> A
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> B
</span></span><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>commit</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#66d9ef>C</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>table</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>update</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>set</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;cherry&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>commit</span>;
</span></span></code></pre></div><p>一个只有一条语句的操作(A)也是一个事务。所以实际上不存在「没有事务」的概念。</p><h3 id=trx_id>trx_id</h3><p>和 record 一样，事务也拥有自己的主键。如果一个事务中包含了 modify 语句，那这个事务就会被分配一个全局递增的数字作为这个事务的主键，主键的名称为 trx_id。</p><h3 id=undo-与版本链>undo 与版本链</h3><p>事务操作必须具备原子性；原子性意味着操作能够回滚(rollback)；回滚需要历史记录；历史记录想要保留，最简单的方法是每次 modify 之前都把当前记录保存下来，这样就能在任何时候回到过去了。</p><p>保留下来的历史记录称做撤销日志(undo log)；保存 undo log 的页面类型为 FILE_PAGE_UNDO_LOG；多个 undo page 之间使用指针链接成链表；整个 undo chain 和 record chain 共同形成了一个版本控制系统。</p><p><img src=/images/transcation_lock/undo.jpg alt=undo></p><h3 id=版本号>版本号</h3><p>前文提到，凡是修改记录的事务都会分配一个全局递增的标识符 trx_id。如果每次修改 record 时都把分配的 trx_id 写入记录的 head 部分的话，就能够溯源记录的事务操作。</p><p><img src=/images/transcation_lock/version.jpg alt=undo></p><p>被写入记录的 trx_id 就像 undo chain 的版本号一样，同一个事务操作生成的内容拥有相同的版本号；不同的版本号根据 trx_id 的递增特性可以推断出事务发生的先后顺序。
回滚事务时，只要把该版本号对应的 undo 全部执行一次即可。</p><h3 id=并发控制>并发控制</h3><p>多个操作并发修改相同的资源就会发生并发安全问题。 innodb 根据操作类型(读或写)与隔离等级，对并发安全问题提供了不同程度的解决方案。</p><h4 id=readview>ReadView</h4><p>一般来讲，读操作并不涉及资源的修改，所以没有安全问题。但是如果我们使用的事务隔离等级是 REPEATABLE READ 的话就另当别论了 。REPEATABLE READ 要求一个事务只能读取到已提交的事务修改过的记录。</p><p>那如何才能判断版本链中哪些记录是当前事务开启时已提交的事务产生的记录呢？上文提到的版本号提供了判断事务发生顺序的线索。简单来说，根据版本号的大小就可以判断某条记录对当前事务是否可见。</p><p>不过实际情况肯定要复杂些。innodb 采取的方案是在事务开启时，对当前系统中的事务获取一个称为一致性视图的快照(ReadView)。</p><table><thead><tr><th>key</th><th>Description</th></tr></thead><tbody><tr><td>m_ids</td><td>当前系统中，活跃的事务 id</td></tr><tr><td>min_trx_id</td><td>当前系统中，活跃的事务 id 最小值</td></tr><tr><td>max_trx_id</td><td>系统应该分配下一个事务的 id</td></tr><tr><td>creator_trx_id</td><td>当前事务的 id</td></tr></tbody></table><p>有了 ReadView，只需要按照固定的步骤把某条记录的 trx_id 和视图中的 trx_id 做比较，就可以判断该记录是否对当前事务可见了。如果最新的记录不可见，则顺着版本链寻找 undo 日志中匹配的内容，直到到达链表的尾部。</p><p>这种使用版本号来控制记录可见性的做法，叫做多版本并发控制系统，简称 MVCC。</p><h3 id=lock>Lock</h3><p>使用了 MVCC 方案的读操作叫做快照读(Consistent Read)——他读取的是当前对事务可见的记录。可见的记录既可能是最新记录，也可能是历史记录。
还有一种读取操作只会读取最新的记录，不会读取历史记录。这种读取操作叫做当前读。
另外，写入操作也总是面向版本链最新记录的，所以写操作也是当前读的一种形式。</p><p>并发写一般都是有安全问题的。在数据库领域中并发写的安全问题主要是脏写：</p><p><img src=/images/transcation_lock/zx1.jpg alt=undo></p><p>假设有两个事务 trx1、trx2 同时更新同一条记录的某列为 B、A；</p><p><img src=/images/transcation_lock/zx2.jpg alt=undo></p><p>在两个事务提交之前 trx1 先进行回滚，接着再提交 trx2，然后版本链中的最新记录就会回滚为 trx0 所在的记录。也就是说，trx2 虽然提交了数据，却没有在数据库产生一致性结果，我们称这种情况为更新丢失。</p><blockquote><p>更新丢失不是更新覆盖，更新覆盖常用在 read-compute-write 类型的操作上。指后一个操作的结果覆盖了前一个操作的内容。这些记录在版本链中没有丢失，而是旧记录被新纪录覆盖了。</p></blockquote><p>发生更新丢失的本质原因是因为两个事务同时针对同一条记录进行修改，其中 trx1 的回滚操作覆盖了 trx2 事务写入的数据所造成的。
为了解决这样的问题，innodb 提供的解决方案就是 Lock。</p><p>存储引擎的加锁方案牵扯的变量因素非常多，本文篇幅有限无法详尽讨论。接下来只通过一个 modify 语句作为示例来简要说明在 REPEATABLE READ 隔离等级下的加锁过程。</p><h4 id=加锁过程分析>加锁过程分析</h4><p>在数据库中新建二级索引和聚簇索引如下：</p><p><img src=/images/transcation_lock/lock1.jpg alt=undo></p><p>使用下面的语句更新上图中的记录。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>update</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>set</span> col3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;test&#39;</span> <span style=color:#66d9ef>where</span> col2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;f&#39;</span>;
</span></span></code></pre></div><p>分析加锁过程：</p><ol><li>查询语句的查询条件生成扫描区间 <code>(f,f)</code>。</li><li>查询二级索引，定位满足扫描区间的第一条记录 <code>col2=f</code> 。</li><li>为 <code>col2=f</code> 的记录加上 next-key 排它锁。</li><li>回表扫描聚簇索引，为 <code>id=7</code> 的记录加上 next-key(防止幻读) 排它锁。</li><li>查询二级索引链表中 <code>col2=f</code> 的下一条记录。并为查询到的记录加上 next-key 排它锁。</li><li>回表扫描二级索引对应的聚簇索引，并对该聚簇索引加上 next-key 排它锁。</li><li>重复上述步骤直到遍历完扫描区间中的记录项。</li></ol><p>加锁完成的结果如下图所示：</p><p><img src=/images/transcation_lock/lock2.jpg alt=undo></p><blockquote><p>如果查询语句无法利用索引，那查询条件生成的扫描区间就是 $(-\infty,+\infty)$，最后加锁的范围就是全表。</p></blockquote><p>记录一旦加上了排它锁，在锁被释放之前任何其他事务都无法对当前记录做出更改，这样就解决了脏写的问题。</p><h2 id=结语>结语</h2><p>innodb 解决并发事务的一致性问题主要依靠两个方案—— MVCC 和 Lock。</p><ol><li>MVCC 方案解决了「读操作」的并发问题：<ul><li>脏读。</li><li>幻读。</li><li>不可重复读的问题。</li></ul></li><li>Lock 方案解决了「写操作」的并发问题：<ul><li>脏写。</li></ul></li></ol><p>使用 MVCC 的读操作也称为快照读，因为它读取的内容可能是历史数据；写操作是当前读的一种形式，因为他总是面向最新记录写入数据。</p></section><footer><a class="permalink u-url" href=https://www.chucklin.net/post/transcation-lock/>🔗</a><hr class=post-underline><p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/sql class="post-tag p-category">sql</a></p></footer></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/avator.jpg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:chuck1inzl@gmail.com>Email me</a></p></div><p class=p-note>从事开发工作10年，持续写作4年，现在的身份是一名 freelancer。项目外包、雇佣洽谈等事项请通过邮箱和我联系。</p></div><div id=footer><nav id=article-skip><div class=next><a alt="Newer article" href=https://www.chucklin.net/post/nodejs-design-1/>&larr; Newer</a></div><div class=top><a alt="Top of page" href=#>Top</a></div><div class=prev><a alt="Older article" href=https://www.chucklin.net/post/index-principle/>Older &rarr;</a></div></nav><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>