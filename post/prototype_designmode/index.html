<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>原型设计模式 | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:mikumiku.lch@hotmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><link rel=stylesheet href=https://www.chucklin.net/css/custom.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav></header><div id=content><article class=h-entry><header><h1 class="post-title p-name">原型设计模式</h1><p class=post-date>Posted on
<time class=dt-published datetime=2018-01-03T14:01:23+08:00>3 January, 2018 at 14:01 +0800</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a></p></header><section class="content e-content"><h2 id=什么是原型设计模式>什么是原型设计模式</h2><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建包含了原对象中所有信息的新的对象。
原型设计模式在某种条件下，是一种非常危险的，难以驾驭的设计模式。使用应该慎之又慎。</p><h2 id=原型设计模式怎么用>原型设计模式怎么用</h2><p>原型设计模式没有复杂的概念，它就是用来拷贝对象的。
在 java 中若想使一个对象能够被拷贝，基本上有下面这几种方法：</p><ul><li>实现 Cloneable 接口。</li><li>重写 clone() 方法，并调用 super.clone() 方法获取到拷贝对象</li><li>若目标对象包含复杂对象引用，则继续调用引用对象的 clone() 方法，再将结果 set 到目标对象上去。</li><li>针对复杂的，引用较深的对象，使用内存流+序列化的方式，直接获取到完全拷贝对象。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * 原型设计模式
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Prototype</span> <span style=color:#66d9ef>implements</span> Cloneable<span style=color:#f92672>,</span> Serializable <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> 8196154781151609930L<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>private</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> arrayList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>

    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> models <span style=color:#f92672>=</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>new</span> Object<span style=color:#f92672>(),</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>()};</span>

    <span style=color:#75715e>// final与clone价架构不兼容。因为你无法在初始化以外的地方改变final的引用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Prototype prototype <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Prototype<span style=color:#f92672>();</span>



    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 重写Object的clone方法
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * @return
</span><span style=color:#75715e>     * @throws CloneNotSupportedException
</span><span style=color:#75715e>     */</span>
    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>clone</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> CloneNotSupportedException <span style=color:#f92672>{</span>
        Prototype prototype <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Prototype<span style=color:#f92672>)</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        prototype<span style=color:#f92672>.</span><span style=color:#a6e22e>arrayList</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;)</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>arrayList</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        prototype<span style=color:#f92672>.</span><span style=color:#a6e22e>models</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>models</span><span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
        <span style=color:#75715e>//this.prototype = (Prototype) prototype.clone();
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> prototype<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 通过对象序列化进行深拷贝
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * @return
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>public</span> Prototype <span style=color:#a6e22e>deepClone</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> IOException<span style=color:#f92672>,</span> ClassNotFoundException <span style=color:#f92672>{</span>
        ByteArrayOutputStream bos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream<span style=color:#f92672>();</span>
        ObjectOutputStream outputStream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream<span style=color:#f92672>(</span>bos<span style=color:#f92672>);</span>

        outputStream<span style=color:#f92672>.</span><span style=color:#a6e22e>writeObject</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>

        ByteArrayInputStream bis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayInputStream<span style=color:#f92672>(</span>bos<span style=color:#f92672>.</span><span style=color:#a6e22e>toByteArray</span><span style=color:#f92672>());</span>
        ObjectInputStream ois <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream<span style=color:#f92672>(</span>bis<span style=color:#f92672>);</span>

        <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>Prototype<span style=color:#f92672>)</span> ois<span style=color:#f92672>.</span><span style=color:#a6e22e>readObject</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>


</code></pre></div><h2 id=原型设计模式的设计缺陷和安全隐患>原型设计模式的设计缺陷和安全隐患</h2><p>为什么文章开头说，原型设计模式在某种条件下，是一种非常危险的，难以驾驭的设计模式？这需要从 Cloneable 接口糟糕的设计说起。</p><p>首先，Cloneable 接口没有包含任何方法，实现它的作用是改变了他的父类中受保护的 clone 方法的实现行为，使得 Object 的 clone 方法能够返回一个拷贝对象。这样的接口设计颠覆了 java 的接口设计理念。
往往实现一个接口，是为了告诉客户这个类能够为他做些什么。而 Cloneable 却改变了父类的 clone 方法的行为。这样极端的做法，基本上可以用匪夷所思来形容。</p><p>其次，调用了 java 语言以外的方法创建了对象，同时深拷贝浅拷贝的问题带来了巨大的安全隐患。比如下面这一段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java> <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 测试
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * @param args
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        Prototype prototype <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Prototype<span style=color:#f92672>();</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>prototype<span style=color:#f92672>.</span><span style=color:#a6e22e>models</span><span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span>
        Object object1 <span style=color:#f92672>=</span> prototype<span style=color:#f92672>.</span><span style=color:#a6e22e>models</span><span style=color:#f92672>[</span>0<span style=color:#f92672>];</span>

        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            Prototype clonePrototype <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Prototype<span style=color:#f92672>)</span> prototype<span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>clonePrototype<span style=color:#f92672>.</span><span style=color:#a6e22e>models</span><span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span>
            Object object2 <span style=color:#f92672>=</span> prototype<span style=color:#f92672>.</span><span style=color:#a6e22e>models</span><span style=color:#f92672>[</span>0<span style=color:#f92672>];</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>object1 <span style=color:#f92672>==</span> object2<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CloneNotSupportedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

</code></pre></div><p>输出结果</p><blockquote><p>java.lang.Object@63947c6b
java.lang.Object@63947c6b
true</p></blockquote><p>这太可怕了。你不得不仔细检查你的每一个属性，直到你确保他们的 clone 都得到调用为止。</p><p>接着，如果你的类设计为了一个不可变类，或者类中有 final 字段的话，那么恭喜，clone 架构与引用可变对象的 final 是不兼容的，clone 方法无法为 final 字段赋值。因为你无法在初始化以外的地方重新改变引用。</p><p>然后，clone 方法“意料之中”的不是同步的。这意味着如果想让你的对象在并发中安全的话，则得花心思在 clone 方法的同步处理上。而由于 clone 架构与 fina l 设计理念冲突的原因，你又无法将你的类设计为不可变类！</p><p>最后，如果你的对象是出于被继承的目的而被设计出来的话，那么你的 clone 方法总是会被所有子类重写。所以建议被继承的类保持与 Object 的设计一致，不主动实现 Cloneable 方法。但是你需要覆盖 clone 方法，重写 clone 逻辑，方法保持 protected 的访问权限。这样做得以让子类拥有是否实现接口的自由，并且还能保证你的类能够拥有正确的“深拷贝”行为。</p><p>所以，如果你想要写出健壮，安全，维护性强的代码，你就应该考虑告别 Cloneable 接口。这个世界上，有些经验丰富的程序员永远不会实现 Cloneable 接口。</p><h2 id=总结>总结</h2><ol><li>原型模式常常和其他设计模式搭配使用。</li><li>注意深浅拷贝的区别。</li><li>鉴于 Cloneable 糟糕的设计，对于任何自定义类，如果你没有充足的把握，请不要实现 Cloneable 接口。凡是实现了 Cloneable 接口的自定义类，一定要给用户提供安全的 clone 实现。</li><li>如果你的自定义类需要并发安全，请花心思对 clone 方法进行同步处理。</li><li>复杂对象建议使用序列化+流的方式重写。这相当安全，并且不容易出错。</li></ol></section><footer><a class="permalink u-url" href=https://www.chucklin.net/post/prototype_designmode/>🔗</a><hr class=post-underline><p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/java class="post-tag p-category">java</a></p></footer></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/avator.jpg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:mikumiku.lch@hotmail.com>Email me</a></p></div><p class=p-note>👋很高兴见到你。我从事开发工作已10年，持续写作4年。现在的身份是一名 freelancer。项目外包，雇佣洽谈等事项请通过邮箱和我联系。</p></div><div id=footer><nav id=article-skip><div class=next><a alt="Newer article" href=https://www.chucklin.net/post/adpater_designmode/>&larr; Newer</a></div><div class=top><a alt="Top of page" href=#>Top</a></div><div class=prev><a alt="Older article" href=https://www.chucklin.net/post/strategy_designmode/>Older &rarr;</a></div></nav><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>