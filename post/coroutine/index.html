<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>协程实战 | ChuckLin's Blog</title><meta name=description content="Love and Peace"><meta name=author content><link rel=apple-touch-icon sizes=180x180 href=https://www.chucklin.net/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.chucklin.net/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.chucklin.net/favicon-16x16.png><link rel=manifest href=https://www.chucklin.net/site.webmanifest><link rel=mask-icon href=https://www.chucklin.net/safari-pinned-tab.svg color=#00416a><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=me href=mailto:mikumiku.lch@hotmail.com><link rel=me href=https://github.com/chuck1in><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=stylesheet href=https://www.chucklin.net/css/fonts.css><link rel=stylesheet href=https://www.chucklin.net/css/style.css><link rel=stylesheet href=https://www.chucklin.net/css/custom.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=sitelogo><a class=glyph alt=Home href=https://www.chucklin.net/><img src=https://www.chucklin.net/images/site-logo.svg alt="Site Logo" height=64px width=64px></a></div><header><nav><div id=page-nav><div class=page-nav-item><a href=https://www.chucklin.net/>Home</a></div><div class=page-nav-item><a href=/about/me><span>About</span></a></div><div class=page-nav-item><a href=/tags><span>Tag</span></a></div></div></nav></header><div id=content><article class=h-entry><header><h1 class="post-title p-name">协程实战</h1><p class=post-date>Posted on
<time class=dt-published datetime=2020-01-16T09:23:00+08:00>16 January, 2020 at 09:23 +0800</time> by <a href=https://www.chucklin.net/ class="p-author h-card" rel=author>Chuck Lin</a></p></header><section class="content e-content"><h2 id=并发与并行>并发与并行</h2><p>计算机自诞生以来，有两方面的性能在持续改进。一是尝试让计算机运行的更快，我们设计了并发使系统具备处理多个任务的能力。二是人类在尝试让计算机做的更多，我们设计了并行使系统可以同时运行多个任务。</p><blockquote><p>我们利用术语并发（concurrency）来指一个同时具有多个活动的系统。用并行（parallelism）指代同时运行几个任务使一个系统运行的更快。</p></blockquote><p>Erlang 之父 Joe Armstrong 用一张 5 岁小孩都能看懂的图解释了并发与并行的区别</p><p><img src=http://static.zybuluo.com/mikumikulch/ewr4jip3mpu1z0pyokxuu46p/v2-674f0d37fca4fac1bd2df28a2b78e633_hd.jpg alt=v2-674f0d37fca4fac1bd2df28a2b78e633_hd.jpg-19.2kB></p><p>并发就是两个队列的顾客一起去一个窗口买咖啡。并行是两个队列的人分别去两个窗口买咖啡。</p><p>并发和串行处理有什么区别？</p><p>并发中的队列里的人一旦买完咖啡后就马上去别的地方等着咖啡煮好，轮到队列中的下一位顾客。而串行处理则是上一位顾客买好咖啡直到咖啡煮好后，才轮到队列中的下一位顾客购买咖啡。</p><p>为使并发与并行在计算机中得到广泛的应用，操作系统屏蔽了底层硬件细节，提供了进程与线程两种抽象供开发人员使用，这就是线程的由来。</p><p>线程的概念想必你已经很熟悉了。同一个进程由多个称为线程的执行单元组成，线程们共享一个进程上下文。cpu 在多个线程之间由操作系统调度器进行切换，并保存当前线程状态到寄存器或主存。</p><p>除了线程以外，还有什么可以使计算机具备多任务处理能力的技术吗？答案是有。使用协程也能实现并发程序。</p><h2 id=为什么使用协程>为什么使用协程</h2><p>协程是一种已经存在了几十年的轻量级线程，这种抽象技术具备线程的大部分特点。利用协程也能设计出支持并发的程序。与线程的不同之处在于，协程不是抢占式的，你在代码中必须标注出什么时候可以安全的暂停执行当前任务，让位给其他任务。</p><p>学术定义总是枯燥难懂，还是代码示例更加的平易近人。来看下面的例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。下面是一个用 python 的协程实现的一个生产者消费者模型。给自己 20 分钟，近距离观察这个模型，快速构建协程在你大脑中的基本面貌，分析新模型的优缺点。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>
<span style=color:#75715e># 生成器函数（消费者）</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>consumer</span>():

r <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>

<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:

<span style=color:#75715e># 切换任务到生产者并 yield 结果</span>

n <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> r

<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> n:

<span style=color:#66d9ef>return</span>

print(<span style=color:#e6db74>&#39;[CONSUMER] Consuming </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>...&#39;</span> <span style=color:#f92672>%</span> n)

r <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;200 OK&#39;</span>

<span style=color:#75715e># 生产者</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>produce</span>(c):

<span style=color:#75715e># 开启生成器</span>

c<span style=color:#f92672>.</span>send(<span style=color:#66d9ef>None</span>)

n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>while</span> n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>:

n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>

print(<span style=color:#e6db74>&#39;[PRODUCER] Producing </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>...&#39;</span> <span style=color:#f92672>%</span> n)

<span style=color:#75715e># 切换任务到消费者</span>

r <span style=color:#f92672>=</span> c<span style=color:#f92672>.</span>send(n)

print(<span style=color:#e6db74>&#39;[PRODUCER] Consumer return: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> r)

c<span style=color:#f92672>.</span>close()

c <span style=color:#f92672>=</span> consumer()

produce(c)

</code></pre></div><p>执行结果</p><pre><code>
[PRODUCER] Producing 1...

[CONSUMER] Consuming 1...

[PRODUCER] Consumer return: 200 OK

[PRODUCER] Producing 2...

[CONSUMER] Consuming 2...

[PRODUCER] Consumer return: 200 OK

[PRODUCER] Producing 3...

[CONSUMER] Consuming 3...

[PRODUCER] Consumer return: 200 OK

[PRODUCER] Producing 4...

[CONSUMER] Consuming 4...

[PRODUCER] Consumer return: 200 OK

[PRODUCER] Producing 5...

[CONSUMER] Consuming 5...

[PRODUCER] Consumer return: 200 OK

</code></pre><p>模型改用协程，生产者生产消息后直接通过 yield 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</p><p>可见，协程本质上就是一个线程的异步串行处理。 它和 nodejs 的异步回调在感觉上有些类似。所以，使用协程时要尽量选择与多路复用 IO 模型等非阻塞 IO 模型进行搭配，以发挥异步处理的最大优势。</p><p>由此可见，相比线程，协程实现的并发逻辑具备无锁、轻量级（无上下文切换）、逻辑简单开发快速等特点。在业务场景合适的情况下，没有理由不选择协程。</p><h2 id=更多的业务场景>更多的业务场景</h2><p>到此协程的基本概念应该已经在你的大脑中留下了一些痕迹。接着请允许我再介绍一个协程的经典示例，帮助你让协程在脑海里变得更加清晰牢固。</p><p>凡是谈到协程的运用，就一定得提到 lua。或许是因为 lua 不支持线程的缘故，在这门纯粹的面向原型的编程语言中协程得到了大量运用。来看一个通过协程与生成器相结合，使用几十行代码开发的一个定时任务调度器。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua>
<span style=color:#75715e>-- 进攻函数</span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>punch</span>( ... )

<span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>5</span> <span style=color:#66d9ef>do</span>

print(<span style=color:#e6db74>&#39;punch&#39;</span> <span style=color:#f92672>..</span> i)

<span style=color:#75715e>-- yelid 执行秒数 下次执行位置</span>

scheduler.wait(<span style=color:#ae81ff>1.0</span>)

<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>end</span>

<span style=color:#75715e>-- 防守函数</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>block</span>( ... )

<span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span> <span style=color:#66d9ef>do</span>

print(<span style=color:#e6db74>&#39;block&#39;</span> <span style=color:#f92672>..</span> i)

<span style=color:#75715e>-- yelid 执行秒数 下次执行位置</span>

scheduler.wait(<span style=color:#ae81ff>2.0</span>)

<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>end</span>

<span style=color:#75715e>-- 创建协程任务</span>

scheduler.schedule(<span style=color:#ae81ff>0.0</span>,coroutine.create(punch))

scheduler.schedule(<span style=color:#ae81ff>0.0</span>,coroutine.create(block))

<span style=color:#75715e>-- 待处理任务队列</span>

<span style=color:#66d9ef>local</span> pending <span style=color:#f92672>=</span> {}

<span style=color:#75715e>-- 入队函数</span>

<span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>schedule</span>(time,action)

pending[<span style=color:#f92672>#</span>pending <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> {

time <span style=color:#f92672>=</span> time,

action <span style=color:#f92672>=</span> action

}

<span style=color:#75715e>-- 按照未来执行时间排序</span>

sort_by_time(pending)

<span style=color:#66d9ef>end</span>

<span style=color:#75715e>-- 任务执行出让函数</span>

<span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wait</span>(seconds)

coroutine.yield(seconds)

<span style=color:#66d9ef>end</span>

<span style=color:#75715e>-- 主函数</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>run</span>()

<span style=color:#75715e>-- 从队列中获取处理任务</span>

<span style=color:#66d9ef>while</span> <span style=color:#f92672>#</span>pending <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>do</span>

<span style=color:#66d9ef>while</span> os.clock() <span style=color:#f92672>&lt;</span> pending[<span style=color:#ae81ff>1</span>].time <span style=color:#66d9ef>do</span> <span style=color:#66d9ef>end</span> <span style=color:#75715e>-- busy-wait</span>

<span style=color:#75715e>-- 移除任务</span>

<span style=color:#66d9ef>local</span> item <span style=color:#f92672>=</span> remove_first(pending)

<span style=color:#75715e>-- 执行生成器</span>

<span style=color:#66d9ef>local</span> _, seconds <span style=color:#f92672>=</span> coroutine.resume(item.action)

<span style=color:#75715e>-- 将任务加上生成器 yelid 回来的执行时间，放回待处理队列中</span>

<span style=color:#66d9ef>if</span> seconds <span style=color:#66d9ef>then</span>

later <span style=color:#f92672>=</span> os.clock() <span style=color:#f92672>+</span> seconds

sschedule(later, item.action)

<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>end</span>

</code></pre></div><p>除了必须利用 busy-wait 进行等待这一小块儿不够优雅的瑕疵以外，我几乎找不出协程实现的调度器有什么缺点。反而因为协程的使用让程序更加的易读了。</p><h2 id=结语>结语</h2><p>协程让你从并发锁、上下文切换、线程通信、共享内存等桎梏中解脱出来，专心于业务逻辑的思考，极大提高了开发效率。清晰明了的结构让代码具备极高的维护性。单线程的特点可节省上下文切换的开销。另外，协程往往需要配合「生成器」使用，以确保函数在栈里面运行的状态能够得到「暂存」。</p><p>所以，当今后再次遇到并发程序的开发时，试试把你的逻辑交给协程。现在，想想你的代码中哪些地方可以使用到协程？</p><hr><p><em>参考书籍</em></p><p><em>《深入理解计算机系统》</em></p><p><em>《七周七语言-卷 2》</em></p><p><em>参考内容</em></p><p><em><a href=https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000>廖雪峰的官网</a></em></p></section><footer><a class="permalink u-url" href=https://www.chucklin.net/post/coroutine/>🔗</a><hr class=post-underline><p class=post-tag>Tags for this post:
<a href=https://www.chucklin.net/tags/java class="post-tag p-category">java</a></p></footer></article></div><div class=h-card><img class=u-photo src=https://www.chucklin.net/images/avator.jpg><div class=card-content><h2 class=card-name><a class="p-name u-url" href=https://www.chucklin.net/ rel=me>Chuck Lin</a></h2><p class=card-subhead><span class=p-locality>Chengdu</span>,
<span class=p-country-name>China</span><br><a class=u-email href=mailto:mikumiku.lch@hotmail.com>Email me</a></p></div><p class=p-note>👋很高兴见到你。我从事开发工作已10年，持续写作4年。现在的身份是一名 freelancer。项目外包，雇佣洽谈等事项请通过邮箱和我联系。</p></div><div id=footer><nav id=article-skip><div class=next><a alt="Newer article" href=https://www.chucklin.net/post/webapi/>&larr; Newer</a></div><div class=top><a alt="Top of page" href=#>Top</a></div><div class=prev><a alt="Older article" href=https://www.chucklin.net/post/genericity/>Older &rarr;</a></div></nav><aside id=social><div id=social-icons><div class=icon-24x24><a class=glyph alt="GitHub profile" href=https://github.com/chuck1in><img src=https://www.chucklin.net/icons/github.svg height=24px width=24px></a></div></div></aside><p class=copyright>Copyright © 2021 Chuck Lin. All rights reserved.</p></div></body></html>